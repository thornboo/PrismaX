# 测试规范

> 本文档描述 PrismaX-Desktop 测试策略和规范

---

## 概述

PrismaX-Desktop 采用多层测试策略，确保代码质量和功能稳定性。

---

## 测试金字塔

```
                    /\
                   /  \
                  / E2E \
                 / 测试  \
                /----------\
               /  集成测试  \
              /              \
             /------------------\
            /      单元测试      \
           /----------------------\
```

| 测试类型 | 占比 | 执行频率    | 执行时间 |
| -------- | ---- | ----------- | -------- |
| 单元测试 | 70%  | 每次提交    | 秒级     |
| 集成测试 | 20%  | 每次 PR     | 分钟级   |
| E2E 测试 | 10%  | 每日/发布前 | 分钟级   |

---

## 测试工具

| 工具            | 用途               |
| --------------- | ------------------ |
| Vitest          | 单元测试、集成测试 |
| Playwright      | E2E 测试           |
| Testing Library | React 组件测试     |
| MSW             | API Mock           |
| Faker           | 测试数据生成       |

---

## 单元测试

### 文件命名

```
src/
├── utils/
│   ├── format.ts
│   └── format.test.ts      # 单元测试文件
├── hooks/
│   ├── useChat.ts
│   └── useChat.test.ts
```

### 测试结构

```typescript
// format.test.ts
import { describe, it, expect, beforeEach, afterEach, vi } from "vitest";
import { formatDate, formatFileSize, truncateText } from "./format";

describe("formatDate", () => {
  beforeEach(() => {
    // 固定时间以确保测试稳定
    vi.useFakeTimers();
    vi.setSystemTime(new Date("2024-01-15T10:00:00Z"));
  });

  afterEach(() => {
    vi.useRealTimers();
  });

  it("应使用默认格式格式化日期", () => {
    const date = new Date("2024-01-15T08:30:00Z");
    expect(formatDate(date)).toBe("2024-01-15 08:30");
  });

  it("应使用自定义格式格式化日期", () => {
    const date = new Date("2024-01-15T08:30:00Z");
    expect(formatDate(date, "YYYY/MM/DD")).toBe("2024/01/15");
  });

  it("应处理无效日期", () => {
    expect(formatDate(new Date("invalid"))).toBe("无效日期");
  });
});

describe("formatFileSize", () => {
  it.each([
    [0, "0 B"],
    [1023, "1023 B"],
    [1024, "1 KB"],
    [1536, "1.5 KB"],
    [1048576, "1 MB"],
    [1073741824, "1 GB"],
  ])("应将 %i 字节格式化为 %s", (bytes, expected) => {
    expect(formatFileSize(bytes)).toBe(expected);
  });

  it("负值应抛出错误", () => {
    expect(() => formatFileSize(-1)).toThrow("无效的文件大小");
  });
});
```

### 异步测试

```typescript
// api.test.ts
import { describe, it, expect, vi } from "vitest";
import { fetchUserData, createConversation } from "./api";

describe("fetchUserData", () => {
  it("应成功获取用户数据", async () => {
    const mockUser = { id: "1", name: "测试用户" };
    global.fetch = vi.fn().mockResolvedValue({
      ok: true,
      json: () => Promise.resolve(mockUser),
    });

    const result = await fetchUserData("1");

    expect(result).toEqual(mockUser);
    expect(fetch).toHaveBeenCalledWith("/api/users/1");
  });

  it("请求失败时应抛出错误", async () => {
    global.fetch = vi.fn().mockResolvedValue({
      ok: false,
      status: 404,
    });

    await expect(fetchUserData("999")).rejects.toThrow("用户不存在");
  });
});
```

---

## 组件测试

### React 组件测试

```typescript
// ChatInput.test.tsx
import { describe, it, expect, vi } from 'vitest';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { ChatInput } from './ChatInput';

describe('ChatInput', () => {
  it('应渲染输入框', () => {
    render(<ChatInput onSend={vi.fn()} />);

    expect(screen.getByPlaceholderText('输入消息...')).toBeInTheDocument();
  });

  it('点击发送按钮时应调用 onSend', async () => {
    const onSend = vi.fn();
    render(<ChatInput onSend={onSend} />);

    const input = screen.getByPlaceholderText('输入消息...');
    await userEvent.type(input, 'Hello');

    const submitButton = screen.getByRole('button', { name: /发送/i });
    await userEvent.click(submitButton);

    expect(onSend).toHaveBeenCalledWith('Hello');
  });

  it('按 Enter 时应调用 onSend', async () => {
    const onSend = vi.fn();
    render(<ChatInput onSend={onSend} />);

    const input = screen.getByPlaceholderText('输入消息...');
    await userEvent.type(input, 'Hello{enter}');

    expect(onSend).toHaveBeenCalledWith('Hello');
  });

  it('不应提交空消息', async () => {
    const onSend = vi.fn();
    render(<ChatInput onSend={onSend} />);

    const submitButton = screen.getByRole('button', { name: /发送/i });
    await userEvent.click(submitButton);

    expect(onSend).not.toHaveBeenCalled();
  });

  it('加载时应禁用输入', () => {
    render(<ChatInput onSend={vi.fn()} isLoading />);

    expect(screen.getByPlaceholderText('输入消息...')).toBeDisabled();
    expect(screen.getByRole('button', { name: /发送/i })).toBeDisabled();
  });
});
```

### Hook 测试

```typescript
// useChat.test.ts
import { describe, it, expect, vi } from "vitest";
import { renderHook, act, waitFor } from "@testing-library/react";
import { useChat } from "./useChat";

describe("useChat", () => {
  it("应初始化为空消息列表", () => {
    const { result } = renderHook(() => useChat());

    expect(result.current.messages).toEqual([]);
    expect(result.current.isLoading).toBe(false);
  });

  it("发送时应添加用户消息", async () => {
    const { result } = renderHook(() => useChat());

    await act(async () => {
      await result.current.sendMessage("Hello");
    });

    expect(result.current.messages).toContainEqual(
      expect.objectContaining({
        role: "user",
        content: "Hello",
      }),
    );
  });

  it("发送时应设置加载状态", async () => {
    const { result } = renderHook(() => useChat());

    act(() => {
      result.current.sendMessage("Hello");
    });

    expect(result.current.isLoading).toBe(true);

    await waitFor(() => {
      expect(result.current.isLoading).toBe(false);
    });
  });
});
```

---

## E2E 测试

### Playwright 配置

```typescript
// playwright.config.ts
import { defineConfig, devices } from "@playwright/test";

export default defineConfig({
  testDir: "./e2e",
  fullyParallel: true,
  forbidOnly: !!process.env.CI,
  retries: process.env.CI ? 2 : 0,
  workers: process.env.CI ? 1 : undefined,
  reporter: "html",
  use: {
    baseURL: "http://localhost:5173",
    trace: "on-first-retry",
    screenshot: "only-on-failure",
  },
  projects: [
    {
      name: "chromium",
      use: { ...devices["Desktop Chrome"] },
    },
  ],
  webServer: {
    command: "pnpm dev",
    url: "http://localhost:5173",
    reuseExistingServer: !process.env.CI,
  },
});
```

### E2E 测试用例

```typescript
// e2e/chat.spec.ts
import { test, expect } from "@playwright/test";

test.describe("聊天功能", () => {
  test.beforeEach(async ({ page }) => {
    await page.goto("/");
  });

  test("应创建新会话", async ({ page }) => {
    // 点击新建会话按钮
    await page.click('[data-testid="new-conversation"]');

    // 验证新会话已创建
    await expect(page.locator('[data-testid="conversation-item"]')).toHaveCount(1);
  });

  test("应发送消息并收到回复", async ({ page }) => {
    // 创建新会话
    await page.click('[data-testid="new-conversation"]');

    // 输入消息
    const input = page.locator('[data-testid="chat-input"]');
    await input.fill("你好");

    // 发送消息
    await page.click('[data-testid="send-button"]');

    // 验证用户消息显示
    await expect(page.locator('[data-testid="user-message"]')).toContainText("你好");

    // 等待 AI 回复
    await expect(page.locator('[data-testid="assistant-message"]')).toBeVisible({
      timeout: 30000,
    });
  });
});
```

---

## 测试覆盖率

### 配置

```typescript
// vitest.config.ts
import { defineConfig } from "vitest/config";

export default defineConfig({
  test: {
    coverage: {
      provider: "v8",
      reporter: ["text", "json", "html"],
      exclude: [
        "node_modules/",
        "dist/",
        "**/*.d.ts",
        "**/*.test.ts",
        "**/*.spec.ts",
        "**/mocks/**",
      ],
      thresholds: {
        lines: 80,
        functions: 80,
        branches: 80,
        statements: 80,
      },
    },
  },
});
```

### 覆盖率要求

| 指标       | 最低要求 | 目标 |
| ---------- | -------- | ---- |
| 行覆盖率   | 80%      | 90%  |
| 函数覆盖率 | 80%      | 90%  |
| 分支覆盖率 | 80%      | 85%  |
| 语句覆盖率 | 80%      | 90%  |

---

## 测试最佳实践

### 命名规范

```typescript
// 使用描述性的测试名称
describe("ChatService", () => {
  describe("sendMessage", () => {
    it("API 调用成功时应返回响应", () => {});
    it("API 返回 500 时应抛出错误", () => {});
    it("网络超时时应重试", () => {});
  });
});
```

### AAA 模式

```typescript
it("应将商品添加到购物车", () => {
  // Arrange（准备）
  const cart = new Cart();
  const item = { id: "1", name: "商品", price: 100 };

  // Act（执行）
  cart.addItem(item);

  // Assert（断言）
  expect(cart.items).toContain(item);
  expect(cart.total).toBe(100);
});
```

### 避免测试实现细节

```typescript
// 错误 - 测试实现细节
it("应将 isLoading 设置为 true", () => {
  component.handleClick();
  expect(component.state.isLoading).toBe(true);
});

// 正确 - 测试行为
it("点击时应显示加载指示器", async () => {
  await userEvent.click(screen.getByRole("button"));
  expect(screen.getByTestId("loading")).toBeVisible();
});
```

### 测试隔离

```typescript
// 每个测试应独立运行
beforeEach(() => {
  // 重置状态
  vi.clearAllMocks();
  localStorage.clear();
});
```
