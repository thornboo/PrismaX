# 消息流设计

> 本文档描述 PrismaX 的消息处理流程设计

---

## 概述

消息流是 PrismaX 的核心功能，涉及用户输入、AI 模型调用、流式响应、消息存储等多个环节。

---

## 消息发送流程

### 整体流程

```
+--------+     +--------+     +--------+     +--------+     +--------+
|  用户   | --> |  UI层  | --> | Store层| --> | Core层 | --> | AI SDK |
| 输入    |     | 组件   |     | Action |     | 处理   |     | 调用   |
+--------+     +--------+     +--------+     +--------+     +----+---+
                                                                 |
                                                                 v
+--------+     +--------+     +--------+     +--------+     +--------+
|  UI    | <-- | Store层| <-- | Core层 | <-- | 流式   | <-- | AI模型 |
| 更新    |     | 更新   |     | 解析   |     | 响应   |     | 服务   |
+--------+     +--------+     +--------+     +--------+     +--------+
```

### 详细步骤

#### 1. 用户输入

```typescript
// ChatInput 组件
function ChatInput() {
  const handleSubmit = async (content: string) => {
    // 1. 验证输入
    if (!content.trim()) return;

    // 2. 调用 Store Action
    await chatStore.sendMessage(content);
  };
}
```

#### 2. Store 处理

```typescript
// chatStore.ts
const useChatStore = create<ChatStore>((set, get) => ({
  sendMessage: async (content: string) => {
    const { activeConversationId, settings } = get();

    // 1. 创建用户消息
    const userMessage: Message = {
      id: generateId(),
      conversationId: activeConversationId,
      role: 'user',
      content,
      createdAt: new Date(),
    };

    // 2. 添加到消息列表
    set((state) => ({
      messages: {
        ...state.messages,
        [activeConversationId]: [
          ...state.messages[activeConversationId],
          userMessage,
        ],
      },
    }));

    // 3. 创建占位 AI 消息
    const assistantMessage: Message = {
      id: generateId(),
      conversationId: activeConversationId,
      role: 'assistant',
      content: '',
      createdAt: new Date(),
    };

    set((state) => ({
      messages: {
        ...state.messages,
        [activeConversationId]: [
          ...state.messages[activeConversationId],
          assistantMessage,
        ],
      },
      isGenerating: true,
    }));

    // 4. 调用 AI 服务
    try {
      const stream = await chatService.sendMessage({
        conversationId: activeConversationId,
        messages: get().messages[activeConversationId],
        model: settings.defaultModel,
      });

      // 5. 处理流式响应
      for await (const chunk of stream) {
        set((state) => ({
          messages: {
            ...state.messages,
            [activeConversationId]: state.messages[activeConversationId].map(
              (msg) =>
                msg.id === assistantMessage.id
                  ? { ...msg, content: msg.content + chunk.content }
                  : msg
            ),
          },
        }));
      }
    } finally {
      set({ isGenerating: false });
    }
  },
}));
```

#### 3. AI SDK 调用

```typescript
// ai-sdk/chat.ts
async function* sendMessage(params: SendMessageParams) {
  const { messages, model, knowledgeBaseIds } = params;

  // 1. 知识库检索（如果启用）
  let context = '';
  if (knowledgeBaseIds?.length) {
    const results = await knowledgeService.search({
      query: messages[messages.length - 1].content,
      knowledgeBaseIds,
    });
    context = formatContext(results);
  }

  // 2. 构建请求消息
  const requestMessages = buildMessages(messages, context);

  // 3. 获取 Provider
  const provider = getProvider(model);

  // 4. 调用模型
  const stream = await provider.chatStream(requestMessages, {
    model,
    temperature: params.temperature,
    maxTokens: params.maxTokens,
  });

  // 5. 转发流式响应
  for await (const chunk of stream) {
    yield chunk;
  }
}
```

---

## 流式响应处理

### SSE 解析

```typescript
// streaming/parser.ts
async function* parseSSEStream(
  response: Response
): AsyncIterable<ChatChunk> {
  const reader = response.body?.getReader();
  if (!reader) throw new Error('No response body');

  const decoder = new TextDecoder();
  let buffer = '';

  while (true) {
    const { done, value } = await reader.read();
    if (done) break;

    buffer += decoder.decode(value, { stream: true });
    const lines = buffer.split('\n');
    buffer = lines.pop() || '';

    for (const line of lines) {
      if (line.startsWith('data: ')) {
        const data = line.slice(6);
        if (data === '[DONE]') return;

        try {
          const parsed = JSON.parse(data);
          yield {
            type: 'text',
            content: parsed.choices[0]?.delta?.content || '',
          };
        } catch {
          // 忽略解析错误
        }
      }
    }
  }
}
```

### 响应转换

```typescript
// streaming/transformer.ts
function transformResponse(chunk: ProviderChunk): ChatChunk {
  // 统一不同 Provider 的响应格式
  switch (chunk.provider) {
    case 'openai':
      return {
        type: 'text',
        content: chunk.choices[0]?.delta?.content || '',
      };
    case 'anthropic':
      return {
        type: 'text',
        content: chunk.delta?.text || '',
      };
    default:
      return {
        type: 'text',
        content: chunk.content || '',
      };
  }
}
```

---

## 消息存储

### Web 版（PostgreSQL）

```typescript
// services/message.ts
class MessageService {
  async saveMessage(message: Message): Promise<Message> {
    const result = await db
      .insert(messages)
      .values({
        id: message.id,
        conversationId: message.conversationId,
        role: message.role,
        content: message.content,
        model: message.model,
        tokensUsed: message.tokensUsed,
        metadata: message.metadata,
      })
      .returning();

    return result[0];
  }

  async updateMessage(id: string, content: string): Promise<Message> {
    const result = await db
      .update(messages)
      .set({ content })
      .where(eq(messages.id, id))
      .returning();

    return result[0];
  }
}
```

### 桌面版（SQLite）

```typescript
// desktop/database.ts
class LocalMessageService {
  saveMessage(message: Message): Message {
    const stmt = this.db.prepare(`
      INSERT INTO messages (id, conversation_id, role, content, model, created_at)
      VALUES (?, ?, ?, ?, ?, ?)
    `);

    stmt.run(
      message.id,
      message.conversationId,
      message.role,
      message.content,
      message.model,
      message.createdAt.toISOString()
    );

    return message;
  }
}
```

---

## 消息重新生成

### 流程

```
1. 用户点击"重新生成"
2. 删除当前 AI 回复
3. 获取上下文消息
4. 重新调用 AI 服务
5. 更新消息内容
```

### 实现

```typescript
// chatStore.ts
regenerateMessage: async (messageId: string) => {
  const { activeConversationId } = get();
  const messages = get().messages[activeConversationId];

  // 1. 找到要重新生成的消息
  const messageIndex = messages.findIndex((m) => m.id === messageId);
  if (messageIndex === -1) return;

  // 2. 获取上下文（该消息之前的所有消息）
  const contextMessages = messages.slice(0, messageIndex);

  // 3. 清空当前消息内容
  set((state) => ({
    messages: {
      ...state.messages,
      [activeConversationId]: state.messages[activeConversationId].map((msg) =>
        msg.id === messageId ? { ...msg, content: '' } : msg
      ),
    },
    isGenerating: true,
  }));

  // 4. 重新调用 AI
  try {
    const stream = await chatService.sendMessage({
      conversationId: activeConversationId,
      messages: contextMessages,
    });

    for await (const chunk of stream) {
      set((state) => ({
        messages: {
          ...state.messages,
          [activeConversationId]: state.messages[activeConversationId].map(
            (msg) =>
              msg.id === messageId
                ? { ...msg, content: msg.content + chunk.content }
                : msg
          ),
        },
      }));
    }
  } finally {
    set({ isGenerating: false });
  }
};
```

---

## 消息编辑

### 流程

```
1. 用户编辑消息
2. 更新消息内容
3. 删除该消息之后的所有消息
4. 如果编辑的是用户消息，重新生成 AI 回复
```

### 实现

```typescript
// chatStore.ts
editMessage: async (messageId: string, newContent: string) => {
  const { activeConversationId } = get();
  const messages = get().messages[activeConversationId];

  // 1. 找到消息位置
  const messageIndex = messages.findIndex((m) => m.id === messageId);
  if (messageIndex === -1) return;

  const message = messages[messageIndex];

  // 2. 更新消息内容，删除后续消息
  set((state) => ({
    messages: {
      ...state.messages,
      [activeConversationId]: state.messages[activeConversationId]
        .slice(0, messageIndex + 1)
        .map((msg) =>
          msg.id === messageId ? { ...msg, content: newContent } : msg
        ),
    },
  }));

  // 3. 如果是用户消息，重新生成 AI 回复
  if (message.role === 'user') {
    await get().sendMessage(newContent, { skipUserMessage: true });
  }
};
```

---

## 停止生成

### 实现

```typescript
// chatStore.ts
const abortControllerRef = { current: null as AbortController | null };

sendMessage: async (content: string) => {
  // 创建 AbortController
  abortControllerRef.current = new AbortController();

  try {
    const stream = await chatService.sendMessage({
      // ...
      signal: abortControllerRef.current.signal,
    });

    for await (const chunk of stream) {
      // 检查是否被中止
      if (abortControllerRef.current?.signal.aborted) {
        break;
      }
      // 处理 chunk
    }
  } catch (error) {
    if (error.name === 'AbortError') {
      // 用户主动停止，不是错误
      return;
    }
    throw error;
  }
};

stopGeneration: () => {
  abortControllerRef.current?.abort();
  set({ isGenerating: false });
};
```

---

## 错误处理

### 错误类型

| 错误类型 | 说明 | 处理方式 |
|----------|------|----------|
| NetworkError | 网络错误 | 提示重试 |
| AuthError | 认证错误 | 提示检查 API Key |
| RateLimitError | 频率限制 | 提示稍后重试 |
| ModelError | 模型错误 | 显示错误信息 |
| TimeoutError | 超时 | 提示重试 |

### 错误处理

```typescript
// chatStore.ts
sendMessage: async (content: string) => {
  try {
    // ... 发送消息
  } catch (error) {
    // 更新消息状态为错误
    set((state) => ({
      messages: {
        ...state.messages,
        [activeConversationId]: state.messages[activeConversationId].map(
          (msg) =>
            msg.id === assistantMessage.id
              ? {
                  ...msg,
                  error: {
                    type: getErrorType(error),
                    message: getErrorMessage(error),
                  },
                }
              : msg
        ),
      },
      isGenerating: false,
    }));

    // 显示错误提示
    toast.error(getErrorMessage(error));
  }
};
```

---

## 性能优化

### 虚拟列表

对于长对话，使用虚拟列表优化渲染：

```typescript
// ChatList.tsx
import { useVirtualizer } from '@tanstack/react-virtual';

function ChatList({ messages }: { messages: Message[] }) {
  const parentRef = useRef<HTMLDivElement>(null);

  const virtualizer = useVirtualizer({
    count: messages.length,
    getScrollElement: () => parentRef.current,
    estimateSize: () => 100,
    overscan: 5,
  });

  return (
    <div ref={parentRef} style={{ height: '100%', overflow: 'auto' }}>
      <div
        style={{
          height: `${virtualizer.getTotalSize()}px`,
          position: 'relative',
        }}
      >
        {virtualizer.getVirtualItems().map((virtualItem) => (
          <div
            key={virtualItem.key}
            style={{
              position: 'absolute',
              top: 0,
              left: 0,
              width: '100%',
              transform: `translateY(${virtualItem.start}px)`,
            }}
          >
            <ChatMessage message={messages[virtualItem.index]} />
          </div>
        ))}
      </div>
    </div>
  );
}
```

### 消息缓存

```typescript
// 使用 React Query 缓存消息
const useMessages = (conversationId: string) => {
  return useQuery({
    queryKey: ['messages', conversationId],
    queryFn: () => messageService.getMessages(conversationId),
    staleTime: 5 * 60 * 1000, // 5 分钟
  });
};
```

### 防抖输入

```typescript
// 输入时防抖保存草稿
const debouncedSaveDraft = useMemo(
  () =>
    debounce((content: string) => {
      localStorage.setItem(`draft-${conversationId}`, content);
    }, 500),
  [conversationId]
);
```
