# 安全设计

> 本文档描述 PrismaX 的安全架构设计

---

## 概述

安全是 PrismaX 的核心关注点之一，涉及用户数据保护、API 密钥管理、网络通信安全、插件沙箱等多个方面。

---

## 安全架构

```
+-------------------------------------------------------------------------+
|                           PrismaX 安全架构                               |
+-------------------------------------------------------------------------+
|                                                                         |
|  +-------------------+     +-------------------+     +-------------------+
|  |   认证授权层       |     |   数据加密层       |     |   访问控制层      |
|  |   (Auth)          |     |   (Encryption)    |     |   (ACL)          |
|  +-------------------+     +-------------------+     +-------------------+
|           |                        |                        |           |
|           v                        v                        v           |
|  +-------------------------------------------------------------------+  |
|  |                         安全中间件层                                |  |
|  |  +-------------+  +-------------+  +-------------+  +-------------+ |
|  |  | 输入验证    |  | 速率限制    |  | 审计日志    |  | 异常检测    | |
|  |  +-------------+  +-------------+  +-------------+  +-------------+ |
|  +-------------------------------------------------------------------+  |
|                                                                         |
+-------------------------------------------------------------------------+
```

---

## 认证与授权

### Web 版认证

```typescript
// auth/jwt.ts
interface JWTPayload {
  userId: string;
  email: string;
  role: UserRole;
  iat: number;
  exp: number;
}

class JWTService {
  private readonly secret: string;
  private readonly accessTokenExpiry = '15m';
  private readonly refreshTokenExpiry = '7d';

  generateTokens(user: User): TokenPair {
    const payload: JWTPayload = {
      userId: user.id,
      email: user.email,
      role: user.role,
      iat: Math.floor(Date.now() / 1000),
      exp: 0, // 由 jwt.sign 设置
    };

    const accessToken = jwt.sign(payload, this.secret, {
      expiresIn: this.accessTokenExpiry,
    });

    const refreshToken = jwt.sign(
      { userId: user.id, type: 'refresh' },
      this.secret,
      { expiresIn: this.refreshTokenExpiry }
    );

    return { accessToken, refreshToken };
  }

  verifyToken(token: string): JWTPayload {
    try {
      return jwt.verify(token, this.secret) as JWTPayload;
    } catch (error) {
      throw new AuthenticationError('Invalid token');
    }
  }

  async refreshAccessToken(refreshToken: string): Promise<string> {
    const payload = this.verifyToken(refreshToken);

    // 检查是否在黑名单中
    if (await this.isTokenBlacklisted(refreshToken)) {
      throw new AuthenticationError('Token has been revoked');
    }

    const user = await userService.findById(payload.userId);
    if (!user) {
      throw new AuthenticationError('User not found');
    }

    return this.generateTokens(user).accessToken;
  }

  private async isTokenBlacklisted(token: string): Promise<boolean> {
    const hash = crypto.createHash('sha256').update(token).digest('hex');
    return await redis.exists(`blacklist:${hash}`);
  }
}
```

### 密码安全

```typescript
// auth/password.ts
import argon2 from 'argon2';

class PasswordService {
  private readonly options: argon2.Options = {
    type: argon2.argon2id,
    memoryCost: 65536, // 64 MB
    timeCost: 3,
    parallelism: 4,
  };

  async hash(password: string): Promise<string> {
    return argon2.hash(password, this.options);
  }

  async verify(hash: string, password: string): Promise<boolean> {
    try {
      return await argon2.verify(hash, password);
    } catch {
      return false;
    }
  }

  validateStrength(password: string): ValidationResult {
    const errors: string[] = [];

    if (password.length < 8) {
      errors.push('Password must be at least 8 characters');
    }
    if (!/[A-Z]/.test(password)) {
      errors.push('Password must contain uppercase letter');
    }
    if (!/[a-z]/.test(password)) {
      errors.push('Password must contain lowercase letter');
    }
    if (!/[0-9]/.test(password)) {
      errors.push('Password must contain number');
    }
    if (!/[^A-Za-z0-9]/.test(password)) {
      errors.push('Password must contain special character');
    }

    return {
      valid: errors.length === 0,
      errors,
    };
  }
}
```

### 桌面版认证

桌面版为单用户模式，使用本地密钥保护：

```typescript
// desktop/auth.ts
class DesktopAuth {
  private keytar = require('keytar');
  private readonly serviceName = 'PrismaX';

  async setMasterPassword(password: string): Promise<void> {
    const salt = crypto.randomBytes(32);
    const hash = await this.hashPassword(password, salt);

    await this.keytar.setPassword(
      this.serviceName,
      'master-password',
      JSON.stringify({ hash, salt: salt.toString('hex') })
    );
  }

  async verifyMasterPassword(password: string): Promise<boolean> {
    const stored = await this.keytar.getPassword(
      this.serviceName,
      'master-password'
    );

    if (!stored) return false;

    const { hash, salt } = JSON.parse(stored);
    const inputHash = await this.hashPassword(
      password,
      Buffer.from(salt, 'hex')
    );

    return crypto.timingSafeEqual(
      Buffer.from(hash),
      Buffer.from(inputHash)
    );
  }

  private async hashPassword(
    password: string,
    salt: Buffer
  ): Promise<string> {
    return new Promise((resolve, reject) => {
      crypto.pbkdf2(password, salt, 100000, 64, 'sha512', (err, key) => {
        if (err) reject(err);
        else resolve(key.toString('hex'));
      });
    });
  }
}
```

---

## API 密钥管理

### 密钥加密存储

```typescript
// security/key-manager.ts
class APIKeyManager {
  private readonly algorithm = 'aes-256-gcm';
  private masterKey: Buffer;

  constructor(masterKey: Buffer) {
    this.masterKey = masterKey;
  }

  encrypt(apiKey: string): EncryptedKey {
    const iv = crypto.randomBytes(16);
    const cipher = crypto.createCipheriv(this.algorithm, this.masterKey, iv);

    let encrypted = cipher.update(apiKey, 'utf8', 'hex');
    encrypted += cipher.final('hex');

    const authTag = cipher.getAuthTag();

    return {
      encrypted,
      iv: iv.toString('hex'),
      authTag: authTag.toString('hex'),
    };
  }

  decrypt(encryptedKey: EncryptedKey): string {
    const decipher = crypto.createDecipheriv(
      this.algorithm,
      this.masterKey,
      Buffer.from(encryptedKey.iv, 'hex')
    );

    decipher.setAuthTag(Buffer.from(encryptedKey.authTag, 'hex'));

    let decrypted = decipher.update(encryptedKey.encrypted, 'hex', 'utf8');
    decrypted += decipher.final('utf8');

    return decrypted;
  }
}
```

### 密钥轮换

```typescript
// security/key-rotation.ts
class KeyRotationService {
  async rotateKeys(): Promise<void> {
    // 1. 生成新的主密钥
    const newMasterKey = crypto.randomBytes(32);

    // 2. 获取所有加密的 API 密钥
    const encryptedKeys = await db.select().from(apiKeys);

    // 3. 使用旧密钥解密，新密钥重新加密
    const oldManager = new APIKeyManager(this.currentMasterKey);
    const newManager = new APIKeyManager(newMasterKey);

    for (const key of encryptedKeys) {
      const decrypted = oldManager.decrypt(key);
      const reEncrypted = newManager.encrypt(decrypted);

      await db
        .update(apiKeys)
        .set({
          encrypted: reEncrypted.encrypted,
          iv: reEncrypted.iv,
          authTag: reEncrypted.authTag,
        })
        .where(eq(apiKeys.id, key.id));
    }

    // 4. 更新主密钥
    await this.updateMasterKey(newMasterKey);
  }
}
```

---

## 数据加密

### 传输加密

所有网络通信使用 TLS 1.3：

```typescript
// server/https.ts
const httpsOptions = {
  key: fs.readFileSync('private-key.pem'),
  cert: fs.readFileSync('certificate.pem'),
  minVersion: 'TLSv1.3',
  ciphers: [
    'TLS_AES_256_GCM_SHA384',
    'TLS_CHACHA20_POLY1305_SHA256',
    'TLS_AES_128_GCM_SHA256',
  ].join(':'),
};
```

### 静态数据加密

```typescript
// security/data-encryption.ts
class DataEncryption {
  // 敏感字段加密
  encryptField(value: string, fieldKey: Buffer): string {
    const iv = crypto.randomBytes(12);
    const cipher = crypto.createCipheriv('aes-256-gcm', fieldKey, iv);

    let encrypted = cipher.update(value, 'utf8');
    encrypted = Buffer.concat([encrypted, cipher.final()]);

    const authTag = cipher.getAuthTag();

    return Buffer.concat([iv, authTag, encrypted]).toString('base64');
  }

  decryptField(encrypted: string, fieldKey: Buffer): string {
    const data = Buffer.from(encrypted, 'base64');

    const iv = data.subarray(0, 12);
    const authTag = data.subarray(12, 28);
    const ciphertext = data.subarray(28);

    const decipher = crypto.createDecipheriv('aes-256-gcm', fieldKey, iv);
    decipher.setAuthTag(authTag);

    let decrypted = decipher.update(ciphertext);
    decrypted = Buffer.concat([decrypted, decipher.final()]);

    return decrypted.toString('utf8');
  }
}
```

### 数据库字段加密

```typescript
// database/encrypted-column.ts
import { customType } from 'drizzle-orm/pg-core';

const encryptedText = customType<{
  data: string;
  driverData: string;
}>({
  dataType() {
    return 'text';
  },
  toDriver(value: string): string {
    return dataEncryption.encryptField(value, fieldKey);
  },
  fromDriver(value: string): string {
    return dataEncryption.decryptField(value, fieldKey);
  },
});

// 使用
export const apiKeys = pgTable('api_keys', {
  id: uuid('id').primaryKey(),
  provider: varchar('provider', { length: 50 }).notNull(),
  apiKey: encryptedText('api_key').notNull(), // 自动加密
  createdAt: timestamp('created_at').defaultNow(),
});
```

---

## 输入验证

### Schema 验证

```typescript
// validation/schemas.ts
import { z } from 'zod';

// 消息输入验证
export const messageSchema = z.object({
  content: z
    .string()
    .min(1, 'Message cannot be empty')
    .max(100000, 'Message too long')
    .refine(
      (val) => !containsMaliciousContent(val),
      'Message contains prohibited content'
    ),
  conversationId: z.string().uuid(),
  model: z.string().optional(),
});

// 文件上传验证
export const fileUploadSchema = z.object({
  filename: z
    .string()
    .max(255)
    .refine(
      (val) => !val.includes('..') && !val.includes('/'),
      'Invalid filename'
    ),
  mimeType: z.enum([
    'application/pdf',
    'text/plain',
    'text/markdown',
    'application/msword',
    'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
  ]),
  size: z.number().max(50 * 1024 * 1024), // 50MB
});

// URL 验证
export const urlSchema = z
  .string()
  .url()
  .refine(
    (url) => {
      const parsed = new URL(url);
      return ['http:', 'https:'].includes(parsed.protocol);
    },
    'Only HTTP(S) URLs are allowed'
  );
```

### XSS 防护

```typescript
// security/xss.ts
import DOMPurify from 'isomorphic-dompurify';

class XSSProtection {
  sanitizeHTML(html: string): string {
    return DOMPurify.sanitize(html, {
      ALLOWED_TAGS: [
        'p', 'br', 'strong', 'em', 'u', 's',
        'h1', 'h2', 'h3', 'h4', 'h5', 'h6',
        'ul', 'ol', 'li',
        'blockquote', 'code', 'pre',
        'a', 'img',
        'table', 'thead', 'tbody', 'tr', 'th', 'td',
      ],
      ALLOWED_ATTR: ['href', 'src', 'alt', 'title', 'class'],
      ALLOW_DATA_ATTR: false,
    });
  }

  escapeForDisplay(text: string): string {
    const escapeMap: Record<string, string> = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#x27;',
    };

    return text.replace(/[&<>"']/g, (char) => escapeMap[char]);
  }
}
```

### SQL 注入防护

使用参数化查询（Drizzle ORM 自动处理）：

```typescript
// 安全的查询方式
const messages = await db
  .select()
  .from(messagesTable)
  .where(eq(messagesTable.conversationId, conversationId));

// 禁止的方式（原始 SQL 拼接）
// const messages = await db.execute(
//   `SELECT * FROM messages WHERE conversation_id = '${conversationId}'`
// );
```

---

## 速率限制

### 实现

```typescript
// middleware/rate-limit.ts
import { Ratelimit } from '@upstash/ratelimit';
import { Redis } from '@upstash/redis';

const ratelimit = new Ratelimit({
  redis: Redis.fromEnv(),
  limiter: Ratelimit.slidingWindow(100, '1 m'), // 每分钟 100 次
  analytics: true,
});

// 不同端点的限制
const rateLimits = {
  'message.send': { requests: 20, window: '1 m' },
  'knowledge.upload': { requests: 10, window: '1 h' },
  'auth.login': { requests: 5, window: '15 m' },
  default: { requests: 100, window: '1 m' },
};

async function rateLimitMiddleware(
  req: Request,
  endpoint: string
): Promise<void> {
  const ip = getClientIP(req);
  const userId = req.user?.id;
  const identifier = userId || ip;

  const limit = rateLimits[endpoint] || rateLimits.default;
  const limiter = new Ratelimit({
    redis: Redis.fromEnv(),
    limiter: Ratelimit.slidingWindow(limit.requests, limit.window),
  });

  const { success, remaining, reset } = await limiter.limit(
    `${endpoint}:${identifier}`
  );

  if (!success) {
    throw new RateLimitError({
      retryAfter: reset,
      remaining: 0,
    });
  }
}
```

---

## 插件安全

### 沙箱隔离

```typescript
// plugins/sandbox.ts
import { VM } from 'vm2';

class PluginSandbox {
  private vm: VM;

  constructor(permissions: PluginPermissions) {
    this.vm = new VM({
      timeout: 30000,
      sandbox: this.createSandbox(permissions),
      eval: false,
      wasm: false,
    });
  }

  private createSandbox(permissions: PluginPermissions) {
    return {
      // 安全的 console
      console: {
        log: (...args: unknown[]) => this.safeLog('log', args),
        warn: (...args: unknown[]) => this.safeLog('warn', args),
        error: (...args: unknown[]) => this.safeLog('error', args),
      },

      // 受限的 fetch
      fetch: permissions.network
        ? this.createSafeFetch(permissions.allowedDomains)
        : undefined,

      // 受限的存储
      storage: permissions.storage
        ? this.createSafeStorage(permissions.storageQuota)
        : undefined,

      // 禁止的全局对象
      process: undefined,
      require: undefined,
      module: undefined,
      exports: undefined,
      __dirname: undefined,
      __filename: undefined,
      Buffer: undefined,
      setImmediate: undefined,
    };
  }

  private createSafeFetch(allowedDomains: string[]) {
    return async (url: string, options?: RequestInit) => {
      const parsed = new URL(url);

      // 检查域名白名单
      if (!allowedDomains.some((d) => parsed.hostname.endsWith(d))) {
        throw new Error(`Domain ${parsed.hostname} is not allowed`);
      }

      // 禁止访问内网
      if (this.isPrivateIP(parsed.hostname)) {
        throw new Error('Access to private networks is not allowed');
      }

      return fetch(url, {
        ...options,
        headers: {
          ...options?.headers,
          'User-Agent': 'PrismaX-Plugin/1.0',
        },
      });
    };
  }

  private isPrivateIP(hostname: string): boolean {
    const privateRanges = [
      /^localhost$/,
      /^127\./,
      /^10\./,
      /^172\.(1[6-9]|2[0-9]|3[0-1])\./,
      /^192\.168\./,
      /^::1$/,
      /^fe80:/,
    ];

    return privateRanges.some((range) => range.test(hostname));
  }
}
```

### 权限系统

```typescript
// plugins/permissions.ts
interface PluginPermissions {
  // 网络权限
  network: boolean;
  allowedDomains: string[];

  // 存储权限
  storage: boolean;
  storageQuota: number; // bytes

  // 文件系统权限
  filesystem: boolean;
  allowedPaths: string[];

  // 系统权限
  clipboard: boolean;
  notifications: boolean;
}

class PermissionManager {
  async requestPermission(
    pluginId: string,
    permission: keyof PluginPermissions
  ): Promise<boolean> {
    // 检查是否已授权
    const granted = await this.getGrantedPermissions(pluginId);
    if (granted.includes(permission)) {
      return true;
    }

    // 请求用户授权
    const approved = await this.showPermissionDialog(pluginId, permission);
    if (approved) {
      await this.grantPermission(pluginId, permission);
    }

    return approved;
  }

  async revokePermission(
    pluginId: string,
    permission: keyof PluginPermissions
  ): Promise<void> {
    await db
      .delete(pluginPermissions)
      .where(
        and(
          eq(pluginPermissions.pluginId, pluginId),
          eq(pluginPermissions.permission, permission)
        )
      );
  }
}
```

---

## 审计日志

### 日志记录

```typescript
// audit/logger.ts
interface AuditLog {
  id: string;
  timestamp: Date;
  userId: string;
  action: string;
  resource: string;
  resourceId?: string;
  details?: Record<string, unknown>;
  ip: string;
  userAgent: string;
  success: boolean;
  errorMessage?: string;
}

class AuditLogger {
  async log(event: Omit<AuditLog, 'id' | 'timestamp'>): Promise<void> {
    const log: AuditLog = {
      id: generateId(),
      timestamp: new Date(),
      ...event,
    };

    // 写入数据库
    await db.insert(auditLogs).values(log);

    // 敏感操作发送告警
    if (this.isSensitiveAction(event.action)) {
      await this.sendAlert(log);
    }
  }

  private isSensitiveAction(action: string): boolean {
    const sensitiveActions = [
      'user.delete',
      'apiKey.create',
      'apiKey.delete',
      'settings.update',
      'plugin.install',
      'data.export',
    ];

    return sensitiveActions.includes(action);
  }

  async query(filters: AuditLogFilters): Promise<AuditLog[]> {
    let query = db.select().from(auditLogs);

    if (filters.userId) {
      query = query.where(eq(auditLogs.userId, filters.userId));
    }
    if (filters.action) {
      query = query.where(eq(auditLogs.action, filters.action));
    }
    if (filters.startDate) {
      query = query.where(gte(auditLogs.timestamp, filters.startDate));
    }
    if (filters.endDate) {
      query = query.where(lte(auditLogs.timestamp, filters.endDate));
    }

    return query.orderBy(desc(auditLogs.timestamp)).limit(filters.limit || 100);
  }
}
```

### 审计事件

| 事件类型 | 说明 |
|----------|------|
| `auth.login` | 用户登录 |
| `auth.logout` | 用户登出 |
| `auth.passwordChange` | 密码修改 |
| `apiKey.create` | 创建 API 密钥 |
| `apiKey.delete` | 删除 API 密钥 |
| `conversation.delete` | 删除会话 |
| `knowledge.upload` | 上传知识库文档 |
| `plugin.install` | 安装插件 |
| `settings.update` | 更新设置 |
| `data.export` | 导出数据 |

---

## 安全配置

### 环境变量

```bash
# .env.example

# 加密密钥（必须保密）
ENCRYPTION_KEY=your-32-byte-encryption-key-here
JWT_SECRET=your-jwt-secret-key-here

# 数据库（使用 SSL）
DATABASE_URL=postgresql://user:pass@host:5432/db?sslmode=require

# Redis（使用 TLS）
REDIS_URL=rediss://user:pass@host:6379

# 安全配置
CORS_ORIGINS=https://app.prismax.com
RATE_LIMIT_ENABLED=true
AUDIT_LOG_ENABLED=true
```

### 安全头配置

```typescript
// middleware/security-headers.ts
const securityHeaders = {
  'Strict-Transport-Security': 'max-age=31536000; includeSubDomains',
  'X-Content-Type-Options': 'nosniff',
  'X-Frame-Options': 'DENY',
  'X-XSS-Protection': '1; mode=block',
  'Referrer-Policy': 'strict-origin-when-cross-origin',
  'Content-Security-Policy': [
    "default-src 'self'",
    "script-src 'self' 'unsafe-inline'",
    "style-src 'self' 'unsafe-inline'",
    "img-src 'self' data: https:",
    "connect-src 'self' https://api.openai.com https://api.anthropic.com",
    "frame-ancestors 'none'",
  ].join('; '),
  'Permissions-Policy': 'camera=(), microphone=(), geolocation=()',
};
```

---

## 安全检查清单

### 开发阶段

- [ ] 所有用户输入经过验证和清理
- [ ] 敏感数据加密存储
- [ ] API 密钥不硬编码在代码中
- [ ] 使用参数化查询防止 SQL 注入
- [ ] 实现适当的错误处理，不泄露敏感信息

### 部署阶段

- [ ] 启用 HTTPS
- [ ] 配置安全头
- [ ] 启用速率限制
- [ ] 配置 CORS
- [ ] 启用审计日志

### 运维阶段

- [ ] 定期轮换密钥
- [ ] 监控异常访问
- [ ] 定期安全审计
- [ ] 及时更新依赖
- [ ] 备份加密数据
