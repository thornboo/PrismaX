# 安全架构设计

> 本文档描述 PrismaX-Desktop 桌面应用的安全架构设计

---

## 概述

安全是 PrismaX-Desktop 的核心关注点之一，涉及用户数据保护、API Key 管理、进程隔离等方面。

---

## 安全架构

```
┌─────────────────────────────────────────────────────────────────────┐
│                      PrismaX-Desktop 安全架构                                │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │                      渲染进程 (沙箱)                          │   │
│  │  • 无法直接访问 Node.js API                                 │   │
│  │  • 无法直接访问文件系统                                      │   │
│  │  • 只能通过 contextBridge 暴露的 API 与主进程通信            │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                              │                                      │
│                    contextBridge (安全桥接)                         │
│                              │                                      │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │                      主进程 (完全权限)                        │   │
│  │  • 可以访问 Node.js API                                     │   │
│  │  • 可以访问文件系统                                          │   │
│  │  • 可以访问数据库                                            │   │
│  │  • 可以发起网络请求                                          │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 进程隔离

### Electron 安全配置

```typescript
// electron/main.ts
import { BrowserWindow } from "electron";

const mainWindow = new BrowserWindow({
  webPreferences: {
    // 启用上下文隔离
    contextIsolation: true,
    // 禁用 Node.js 集成
    nodeIntegration: false,
    // 禁用远程模块
    enableRemoteModule: false,
    // 使用预加载脚本
    preload: path.join(__dirname, "preload.js"),
    // 启用沙箱
    sandbox: true,
  },
});
```

### 预加载脚本

```typescript
// electron/preload.ts
import { contextBridge, ipcRenderer } from "electron";
import { IPC_CHANNELS, IPC_EVENTS } from "./ipc/channels";

// 只暴露必要的 API
contextBridge.exposeInMainWorld("electron", {
  // 聊天
  chat: {
    send: (input: { conversationId: string; content: string; modelId?: string }) =>
      ipcRenderer.invoke(IPC_CHANNELS.chat.send, input),
    cancel: (requestId: string) => ipcRenderer.invoke(IPC_CHANNELS.chat.cancel, requestId),
    onToken: (callback: (token: string) => void) => {
      const listener = (_: any, token: string) => callback(token);
      ipcRenderer.on(IPC_EVENTS.chat.token, listener);
      return () => ipcRenderer.removeListener(IPC_EVENTS.chat.token, listener);
    },
  },

  // 数据库（只暴露必要操作）
  db: {
    getConversations: () => ipcRenderer.invoke(IPC_CHANNELS.db.getConversations),
    createConversation: (title: string) =>
      ipcRenderer.invoke(IPC_CHANNELS.db.createConversation, title),
    deleteConversation: (id: string) => ipcRenderer.invoke(IPC_CHANNELS.db.deleteConversation, id),
  },

  // 系统
  system: {
    getAppVersion: () => ipcRenderer.invoke(IPC_CHANNELS.system.getAppVersion),
    openExternal: (url: string) => ipcRenderer.invoke(IPC_CHANNELS.system.openExternal, url),
  },
});
```

---

## API Key 管理

### 安全存储

当前实现使用 Electron `safeStorage`（底层依赖系统密钥链能力）对敏感数据进行加密后再落库：

```typescript
// electron/services/secure-storage.ts（节选）
import { safeStorage } from "electron";

export function encryptString(plainText: string): string {
  if (!safeStorage.isEncryptionAvailable()) return plainText;
  const encrypted = safeStorage.encryptString(plainText);
  return `encrypted:${encrypted.toString("base64")}`;
}

export function decryptString(encryptedText: string): string {
  if (!encryptedText.startsWith("encrypted:")) return encryptedText;
  const base64Data = encryptedText.slice("encrypted:".length);
  return safeStorage.decryptString(Buffer.from(base64Data, "base64"));
}
```

并在提供商服务中统一处理：

- `electron/services/provider.ts`：`updateProvider()` 写入时加密 `apiKey`；对 UI 返回时做遮蔽；仅内部调用 `getProviderApiKey()` 才会解密。

### IPC 处理

API Key 的修改通过 `provider:update`（`electron/ipc/handlers.ts` → `electron/services/provider.ts`）完成，遵循统一 `IpcResponse<T>` 返回契约（见 `docs/架构文档/IPC契约.md`）。

---

## 输入验证

当前版本未引入统一的 Schema 校验中间件；关键入口在主进程 handler 内做必要校验，并通过 `IpcResponse<T>` 返回可展示错误信息。

例如外链打开仅允许 `http/https` 协议（见上文“外部链接处理”示例）。

---

## XSS 防护

### React 自动转义

React 默认会转义所有渲染的内容，防止 XSS 攻击：

```typescript
// 安全：React 自动转义
function MessageBubble({ content }: { content: string }) {
  return <div>{content}</div>;
}

// 危险：避免使用 dangerouslySetInnerHTML
// function MessageBubble({ content }: { content: string }) {
//   return <div dangerouslySetInnerHTML={{ __html: content }} />;
// }
```

### Markdown 渲染安全

```typescript
// src/components/chat/MarkdownRenderer.tsx
import ReactMarkdown from 'react-markdown';
import rehypeSanitize from 'rehype-sanitize';

function MarkdownRenderer({ content }: { content: string }) {
  return (
    <ReactMarkdown
      rehypePlugins={[rehypeSanitize]}
      components={{
        // 自定义链接，在新窗口打开
        a: ({ href, children }) => (
          <a
            href={href}
            target="_blank"
            rel="noopener noreferrer"
            onClick={(e) => {
              e.preventDefault();
              if (href) {
                window.electron.system.openExternal(href);
              }
            }}
          >
            {children}
          </a>
        ),
      }}
    >
      {content}
    </ReactMarkdown>
  );
}
```

---

## SQL 注入防护

### Drizzle ORM 参数化查询

```typescript
// 安全：使用 Drizzle ORM 参数化查询
const messages = await db
  .select()
  .from(messagesTable)
  .where(eq(messagesTable.conversationId, conversationId));

// 危险：避免原始 SQL 拼接
// const messages = await db.execute(
//   `SELECT * FROM messages WHERE conversation_id = '${conversationId}'`
// );
```

---

## 网络安全

### 外部链接处理

```typescript
// electron/ipc/handlers.ts（示意）
import { shell } from "electron";

handleIpc(
  IPC_CHANNELS.system.openExternal,
  async (_event, url: string) => {
    const parsed = new URL(url);
    if (!["http:", "https:"].includes(parsed.protocol)) {
      throw new Error(`不允许的协议: ${parsed.protocol}`);
    }
    await shell.openExternal(url);
    return null;
  },
  "打开链接失败",
);
```

### CSP 配置

```typescript
// electron/main.ts
import { session } from "electron";

session.defaultSession.webRequest.onHeadersReceived((details, callback) => {
  callback({
    responseHeaders: {
      ...details.responseHeaders,
      "Content-Security-Policy": [
        "default-src 'self'",
        "script-src 'self'",
        "style-src 'self' 'unsafe-inline'",
        "img-src 'self' data: https:",
        "connect-src 'self' https://api.openai.com https://api.anthropic.com",
      ].join("; "),
    },
  });
});
```

---

## 数据安全

### 本地数据加密

对于敏感数据，可以使用加密存储：

```typescript
// electron/services/crypto.ts
import crypto from "crypto";

const ALGORITHM = "aes-256-gcm";

export class CryptoService {
  private key: Buffer;

  constructor(masterPassword: string) {
    // 从主密码派生密钥
    this.key = crypto.pbkdf2Sync(masterPassword, "prismax-salt", 100000, 32, "sha512");
  }

  encrypt(plaintext: string): string {
    const iv = crypto.randomBytes(16);
    const cipher = crypto.createCipheriv(ALGORITHM, this.key, iv);

    let encrypted = cipher.update(plaintext, "utf8", "hex");
    encrypted += cipher.final("hex");

    const authTag = cipher.getAuthTag();

    return JSON.stringify({
      iv: iv.toString("hex"),
      encrypted,
      authTag: authTag.toString("hex"),
    });
  }

  decrypt(ciphertext: string): string {
    const { iv, encrypted, authTag } = JSON.parse(ciphertext);

    const decipher = crypto.createDecipheriv(ALGORITHM, this.key, Buffer.from(iv, "hex"));

    decipher.setAuthTag(Buffer.from(authTag, "hex"));

    let decrypted = decipher.update(encrypted, "hex", "utf8");
    decrypted += decipher.final("utf8");

    return decrypted;
  }
}
```

### 数据库文件权限

```typescript
// electron/db/index.ts
import fs from "fs";
import path from "path";
import { app } from "electron";

function ensureDbSecurity() {
  const dbPath = path.join(app.getPath("userData"), "prismax.db");

  // 确保数据库文件只有当前用户可读写
  if (process.platform !== "win32") {
    fs.chmodSync(dbPath, 0o600);
  }
}
```

---

## 安全检查清单

### 开发阶段

- [x] 启用 contextIsolation
- [x] 禁用 nodeIntegration
- [x] 使用预加载脚本暴露 API
- [x] 关键入口做必要校验（例如 URL 协议白名单）
- [x] 使用 ORM 参数化查询
- [x] API Key 使用 safeStorage 加密后落库（底层依赖系统密钥链能力）

### 构建阶段

- [ ] 代码签名（macOS/Windows）
- [ ] 启用 ASAR 打包
- [ ] 移除开发依赖

### 运行阶段

- [x] CSP 配置
- [x] 外部链接验证
- [x] 数据库文件权限

---

## 安全更新

### 依赖更新

定期检查和更新依赖：

```bash
# 检查过时依赖
pnpm outdated

# 检查安全漏洞
pnpm audit

# 更新依赖
pnpm update
```

### Electron 更新

及时更新 Electron 版本以获取安全修复：

```bash
# 更新 Electron
pnpm update electron
```
