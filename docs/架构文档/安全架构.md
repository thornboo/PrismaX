# 安全架构设计

> 本文档描述 PrismaX-Desktop 桌面应用的安全架构设计

---

## 概述

安全是 PrismaX-Desktop 的核心关注点之一，涉及用户数据保护、API Key 管理、进程隔离等方面。

---

## 安全架构

```
┌─────────────────────────────────────────────────────────────────────┐
│                      PrismaX-Desktop 安全架构                                │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │                      渲染进程 (沙箱)                          │   │
│  │  • 无法直接访问 Node.js API                                 │   │
│  │  • 无法直接访问文件系统                                      │   │
│  │  • 只能通过 contextBridge 暴露的 API 与主进程通信            │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                              │                                      │
│                    contextBridge (安全桥接)                         │
│                              │                                      │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │                      主进程 (完全权限)                        │   │
│  │  • 可以访问 Node.js API                                     │   │
│  │  • 可以访问文件系统                                          │   │
│  │  • 可以访问数据库                                            │   │
│  │  • 可以发起网络请求                                          │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 进程隔离

### Electron 安全配置

```typescript
// electron/main.ts
import { BrowserWindow } from "electron";

const mainWindow = new BrowserWindow({
  webPreferences: {
    // 启用上下文隔离
    contextIsolation: true,
    // 禁用 Node.js 集成
    nodeIntegration: false,
    // 禁用远程模块
    enableRemoteModule: false,
    // 使用预加载脚本
    preload: path.join(__dirname, "preload.js"),
    // 启用沙箱
    sandbox: true,
  },
});
```

### 预加载脚本

```typescript
// electron/preload.ts
import { contextBridge, ipcRenderer } from "electron";

// 只暴露必要的 API
contextBridge.exposeInMainWorld("electron", {
  // 聊天
  chat: {
    send: (input: ChatInput) => ipcRenderer.invoke("chat:send", input),
    stop: () => ipcRenderer.invoke("chat:stop"),
    onToken: (callback: (token: string) => void) => {
      const listener = (_: any, token: string) => callback(token);
      ipcRenderer.on("chat:token", listener);
      return () => ipcRenderer.removeListener("chat:token", listener);
    },
  },

  // 数据库（只暴露必要操作）
  db: {
    getConversations: () => ipcRenderer.invoke("db:getConversations"),
    createConversation: (title: string) => ipcRenderer.invoke("db:createConversation", title),
    deleteConversation: (id: string) => ipcRenderer.invoke("db:deleteConversation", id),
  },

  // 系统
  system: {
    getAppVersion: () => ipcRenderer.invoke("system:getAppVersion"),
    openExternal: (url: string) => ipcRenderer.invoke("system:openExternal", url),
  },
});
```

---

## API Key 管理

### 安全存储

桌面端使用系统 Keychain 存储 API Key：

```typescript
// electron/services/keychain.ts
import keytar from "keytar";

const SERVICE_NAME = "PrismaX-Desktop";

export class KeychainService {
  async getApiKey(provider: string): Promise<string | null> {
    return keytar.getPassword(SERVICE_NAME, provider);
  }

  async setApiKey(provider: string, apiKey: string): Promise<void> {
    await keytar.setPassword(SERVICE_NAME, provider, apiKey);
  }

  async deleteApiKey(provider: string): Promise<void> {
    await keytar.deletePassword(SERVICE_NAME, provider);
  }

  async listProviders(): Promise<string[]> {
    const credentials = await keytar.findCredentials(SERVICE_NAME);
    return credentials.map((c) => c.account);
  }
}
```

### IPC 处理

```typescript
// electron/ipc/keychain.ts
import { ipcMain } from "electron";
import { KeychainService } from "../services/keychain";

const keychainService = new KeychainService();

export function registerKeychainHandlers() {
  ipcMain.handle("keychain:get", async (_, provider: string) => {
    return keychainService.getApiKey(provider);
  });

  ipcMain.handle("keychain:set", async (_, provider: string, apiKey: string) => {
    // 验证 API Key 格式
    if (!isValidApiKey(provider, apiKey)) {
      throw new Error("Invalid API key format");
    }
    await keychainService.setApiKey(provider, apiKey);
  });

  ipcMain.handle("keychain:delete", async (_, provider: string) => {
    await keychainService.deleteApiKey(provider);
  });

  ipcMain.handle("keychain:list", async () => {
    return keychainService.listProviders();
  });
}

function isValidApiKey(provider: string, apiKey: string): boolean {
  // 基本格式验证
  if (!apiKey || apiKey.length < 10) return false;

  // 提供商特定验证
  switch (provider) {
    case "openai":
      return apiKey.startsWith("sk-");
    case "anthropic":
      return apiKey.startsWith("sk-ant-");
    default:
      return true;
  }
}
```

---

## 输入验证

### Zod Schema 验证

```typescript
// electron/validation/schemas.ts
import { z } from "zod";

// 消息输入验证
export const messageSchema = z.object({
  content: z.string().min(1, "消息不能为空").max(100000, "消息过长"),
  conversationId: z.string().uuid(),
  model: z.string().optional(),
});

// 会话创建验证
export const conversationSchema = z.object({
  title: z.string().max(255).optional(),
  model: z.string().optional(),
  systemPrompt: z.string().max(10000).optional(),
});

// 设置验证
export const settingsSchema = z.object({
  theme: z.enum(["light", "dark", "system"]),
  language: z.string(),
  defaultModel: z.string(),
});
```

### IPC 验证中间件

```typescript
// electron/ipc/middleware.ts
import { z } from "zod";

export function validateInput<T>(schema: z.ZodSchema<T>) {
  return (handler: (input: T) => Promise<any>) => {
    return async (event: any, input: unknown) => {
      const result = schema.safeParse(input);
      if (!result.success) {
        throw new Error(`Validation error: ${result.error.message}`);
      }
      return handler(result.data);
    };
  };
}

// 使用示例
ipcMain.handle(
  "chat:send",
  validateInput(messageSchema)(async (input) => {
    // 处理已验证的输入
  }),
);
```

---

## XSS 防护

### React 自动转义

React 默认会转义所有渲染的内容，防止 XSS 攻击：

```typescript
// 安全：React 自动转义
function MessageBubble({ content }: { content: string }) {
  return <div>{content}</div>;
}

// 危险：避免使用 dangerouslySetInnerHTML
// function MessageBubble({ content }: { content: string }) {
//   return <div dangerouslySetInnerHTML={{ __html: content }} />;
// }
```

### Markdown 渲染安全

```typescript
// src/components/chat/MarkdownRenderer.tsx
import ReactMarkdown from 'react-markdown';
import rehypeSanitize from 'rehype-sanitize';

function MarkdownRenderer({ content }: { content: string }) {
  return (
    <ReactMarkdown
      rehypePlugins={[rehypeSanitize]}
      components={{
        // 自定义链接，在新窗口打开
        a: ({ href, children }) => (
          <a
            href={href}
            target="_blank"
            rel="noopener noreferrer"
            onClick={(e) => {
              e.preventDefault();
              if (href) {
                window.electron.system.openExternal(href);
              }
            }}
          >
            {children}
          </a>
        ),
      }}
    >
      {content}
    </ReactMarkdown>
  );
}
```

---

## SQL 注入防护

### Drizzle ORM 参数化查询

```typescript
// 安全：使用 Drizzle ORM 参数化查询
const messages = await db
  .select()
  .from(messagesTable)
  .where(eq(messagesTable.conversationId, conversationId));

// 危险：避免原始 SQL 拼接
// const messages = await db.execute(
//   `SELECT * FROM messages WHERE conversation_id = '${conversationId}'`
// );
```

---

## 网络安全

### 外部链接处理

```typescript
// electron/ipc/system.ts
import { shell } from "electron";

ipcMain.handle("system:openExternal", async (_, url: string) => {
  // 验证 URL
  const parsed = new URL(url);

  // 只允许 http/https 协议
  if (!["http:", "https:"].includes(parsed.protocol)) {
    throw new Error("Only HTTP(S) URLs are allowed");
  }

  // 使用系统默认浏览器打开
  await shell.openExternal(url);
});
```

### CSP 配置

```typescript
// electron/main.ts
import { session } from "electron";

session.defaultSession.webRequest.onHeadersReceived((details, callback) => {
  callback({
    responseHeaders: {
      ...details.responseHeaders,
      "Content-Security-Policy": [
        "default-src 'self'",
        "script-src 'self'",
        "style-src 'self' 'unsafe-inline'",
        "img-src 'self' data: https:",
        "connect-src 'self' https://api.openai.com https://api.anthropic.com",
      ].join("; "),
    },
  });
});
```

---

## 数据安全

### 本地数据加密

对于敏感数据，可以使用加密存储：

```typescript
// electron/services/crypto.ts
import crypto from "crypto";

const ALGORITHM = "aes-256-gcm";

export class CryptoService {
  private key: Buffer;

  constructor(masterPassword: string) {
    // 从主密码派生密钥
    this.key = crypto.pbkdf2Sync(masterPassword, "prismax-salt", 100000, 32, "sha512");
  }

  encrypt(plaintext: string): string {
    const iv = crypto.randomBytes(16);
    const cipher = crypto.createCipheriv(ALGORITHM, this.key, iv);

    let encrypted = cipher.update(plaintext, "utf8", "hex");
    encrypted += cipher.final("hex");

    const authTag = cipher.getAuthTag();

    return JSON.stringify({
      iv: iv.toString("hex"),
      encrypted,
      authTag: authTag.toString("hex"),
    });
  }

  decrypt(ciphertext: string): string {
    const { iv, encrypted, authTag } = JSON.parse(ciphertext);

    const decipher = crypto.createDecipheriv(ALGORITHM, this.key, Buffer.from(iv, "hex"));

    decipher.setAuthTag(Buffer.from(authTag, "hex"));

    let decrypted = decipher.update(encrypted, "hex", "utf8");
    decrypted += decipher.final("utf8");

    return decrypted;
  }
}
```

### 数据库文件权限

```typescript
// electron/db/index.ts
import fs from "fs";
import path from "path";
import { app } from "electron";

function ensureDbSecurity() {
  const dbPath = path.join(app.getPath("userData"), "prismax.db");

  // 确保数据库文件只有当前用户可读写
  if (process.platform !== "win32") {
    fs.chmodSync(dbPath, 0o600);
  }
}
```

---

## 安全检查清单

### 开发阶段

- [x] 启用 contextIsolation
- [x] 禁用 nodeIntegration
- [x] 使用预加载脚本暴露 API
- [x] 所有用户输入使用 Zod 验证
- [x] 使用 ORM 参数化查询
- [x] API Key 存储在系统 Keychain

### 构建阶段

- [ ] 代码签名（macOS/Windows）
- [ ] 启用 ASAR 打包
- [ ] 移除开发依赖

### 运行阶段

- [x] CSP 配置
- [x] 外部链接验证
- [x] 数据库文件权限

---

## 安全更新

### 依赖更新

定期检查和更新依赖：

```bash
# 检查过时依赖
pnpm outdated

# 检查安全漏洞
pnpm audit

# 更新依赖
pnpm update
```

### Electron 更新

及时更新 Electron 版本以获取安全修复：

```bash
# 更新 Electron
pnpm update electron
```
