# 消息处理流程

> 本文档描述 PrismaX-Desktop 桌面应用的消息处理流程设计

---

## 概述

消息流程是 PrismaX-Desktop 的核心功能，涉及用户输入、AI 模型调用、流式响应、消息存储等环节。

---

## 整体架构

```
┌─────────────────────────────────────────────────────────────────────┐
│                        消息处理流程                                   │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  ┌─────────┐    ┌─────────┐    ┌─────────┐    ┌─────────┐         │
│  │  用户   │───▶│   UI    │───▶│  Store  │───▶│   IPC   │         │
│  │  输入   │    │  组件   │    │  Action │    │  调用   │         │
│  └─────────┘    └─────────┘    └─────────┘    └────┬────┘         │
│                                                     │               │
│                                                     ▼               │
│  ┌─────────┐    ┌─────────┐    ┌─────────┐    ┌─────────┐         │
│  │   UI    │◀───│  Store  │◀───│   IPC   │◀───│ Service │         │
│  │  更新   │    │  更新   │    │  事件   │    │  处理   │         │
│  └─────────┘    └─────────┘    └─────────┘    └────┬────┘         │
│                                                     │               │
│                                                     ▼               │
│                                              ┌─────────┐           │
│                                              │ AI API  │           │
│                                              │  调用   │           │
│                                              └─────────┘           │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 消息发送流程

### 1. 用户输入

```typescript
// src/components/chat/ChatInput.tsx
function ChatInput() {
  const { sendMessage } = useChatStore();

  const handleSubmit = async (content: string) => {
    // 1. 验证输入
    if (!content.trim()) return;

    // 2. 调用 Store Action
    await sendMessage(content);
  };

  return (
    <form onSubmit={handleSubmit}>
      <textarea placeholder="输入消息..." />
      <button type="submit">发送</button>
    </form>
  );
}
```

### 2. Store 处理

```typescript
// src/stores/chat.ts
import { create } from "zustand";

interface ChatStore {
  messages: Record<string, Message[]>;
  isGenerating: boolean;
  sendMessage: (content: string) => Promise<void>;
}

export const useChatStore = create<ChatStore>((set, get) => ({
  messages: {},
  isGenerating: false,

  sendMessage: async (content: string) => {
    const { activeConversationId } = get();

    // 1. 创建用户消息
    const userMessage: Message = {
      id: generateId(),
      conversationId: activeConversationId,
      role: "user",
      content,
      createdAt: new Date().toISOString(),
    };

    // 2. 添加到消息列表
    set((state) => ({
      messages: {
        ...state.messages,
        [activeConversationId]: [...state.messages[activeConversationId], userMessage],
      },
    }));

    // 3. 创建占位 AI 消息
    const assistantMessage: Message = {
      id: generateId(),
      conversationId: activeConversationId,
      role: "assistant",
      content: "",
      createdAt: new Date().toISOString(),
    };

    set((state) => ({
      messages: {
        ...state.messages,
        [activeConversationId]: [...state.messages[activeConversationId], assistantMessage],
      },
      isGenerating: true,
    }));

    // 4. 通过 IPC 调用主进程
    try {
      await window.electron.chat.send({
        conversationId: activeConversationId,
        messages: get().messages[activeConversationId],
      });
    } finally {
      set({ isGenerating: false });
    }
  },
}));
```

### 3. IPC 通信

```typescript
// electron/preload.ts
contextBridge.exposeInMainWorld("electron", {
  chat: {
    send: (input: ChatInput) => ipcRenderer.invoke("chat:send", input),
    onToken: (callback: (token: string) => void) => {
      const listener = (_: any, token: string) => callback(token);
      ipcRenderer.on("chat:token", listener);
      return () => ipcRenderer.removeListener("chat:token", listener);
    },
    onDone: (callback: (data: any) => void) => {
      const listener = (_: any, data: any) => callback(data);
      ipcRenderer.on("chat:done", listener);
      return () => ipcRenderer.removeListener("chat:done", listener);
    },
    onError: (callback: (error: string) => void) => {
      const listener = (_: any, error: string) => callback(error);
      ipcRenderer.on("chat:error", listener);
      return () => ipcRenderer.removeListener("chat:error", listener);
    },
  },
});
```

### 4. 主进程处理

```typescript
// electron/ipc/chat.ts
import { ipcMain, BrowserWindow } from "electron";
import { ChatService } from "../services/chat-service";

export function registerChatHandlers(mainWindow: BrowserWindow) {
  const chatService = new ChatService();

  ipcMain.handle("chat:send", async (event, input: ChatInput) => {
    try {
      // 1. 保存用户消息到数据库
      await chatService.saveMessage(input.messages[input.messages.length - 1]);

      // 2. 调用 AI API（流式）
      const stream = await chatService.chat(input.messages);

      // 3. 流式返回 token
      for await (const chunk of stream) {
        mainWindow.webContents.send("chat:token", chunk);
      }

      // 4. 完成
      mainWindow.webContents.send("chat:done", { success: true });
    } catch (error) {
      mainWindow.webContents.send("chat:error", error.message);
    }
  });
}
```

### 5. ChatService 实现

```typescript
// electron/services/chat-service.ts
import { streamText } from "ai";
import { createOpenAI } from "@ai-sdk/openai";

export class ChatService {
  private messageRepo = new MessageRepository();
  private conversationRepo = new ConversationRepository();

  async *chat(messages: Message[]): AsyncGenerator<string> {
    // 1. 获取 API 配置
    const provider = await this.getProvider();

    // 2. 调用 AI SDK
    const result = await streamText({
      model: provider,
      messages: messages.map((m) => ({
        role: m.role,
        content: m.content,
      })),
    });

    // 3. 流式返回
    let fullContent = "";
    for await (const chunk of result.textStream) {
      fullContent += chunk;
      yield chunk;
    }

    // 4. 保存助手消息
    await this.saveMessage({
      conversationId: messages[0].conversationId,
      role: "assistant",
      content: fullContent,
    });
  }

  async saveMessage(message: Partial<Message>) {
    return this.messageRepo.create(message);
  }

  private async getProvider() {
    const settings = await this.getSettings();
    return createOpenAI({
      apiKey: settings.apiKey,
      baseURL: settings.baseUrl,
    })(settings.model);
  }
}
```

---

## 流式响应处理

### 渲染进程监听

```typescript
// src/hooks/use-chat-stream.ts
import { useEffect } from "react";
import { useChatStore } from "../stores/chat";

export function useChatStream() {
  const { activeConversationId, updateMessage } = useChatStore();

  useEffect(() => {
    // 监听 token
    const unsubToken = window.electron.chat.onToken((token) => {
      updateMessage(activeConversationId, token);
    });

    // 监听完成
    const unsubDone = window.electron.chat.onDone(() => {
      // 处理完成逻辑
    });

    // 监听错误
    const unsubError = window.electron.chat.onError((error) => {
      // 处理错误
    });

    return () => {
      unsubToken();
      unsubDone();
      unsubError();
    };
  }, [activeConversationId]);
}
```

### Store 更新

```typescript
// src/stores/chat.ts
updateMessage: (conversationId: string, token: string) => {
  set((state) => {
    const messages = state.messages[conversationId];
    const lastMessage = messages[messages.length - 1];

    if (lastMessage.role === 'assistant') {
      return {
        messages: {
          ...state.messages,
          [conversationId]: [
            ...messages.slice(0, -1),
            { ...lastMessage, content: lastMessage.content + token },
          ],
        },
      };
    }

    return state;
  });
},
```

---

## 消息重新生成

### 流程

```
1. 用户点击"重新生成"
2. 删除当前 AI 响应
3. 获取上下文消息
4. 重新调用 AI 服务
5. 更新消息内容
```

### 实现

```typescript
// src/stores/chat.ts
regenerateMessage: async (messageId: string) => {
  const { activeConversationId } = get();
  const messages = get().messages[activeConversationId];

  // 1. 找到要重新生成的消息
  const messageIndex = messages.findIndex((m) => m.id === messageId);
  if (messageIndex === -1) return;

  // 2. 获取上下文（该消息之前的所有消息）
  const contextMessages = messages.slice(0, messageIndex);

  // 3. 清空当前消息内容
  set((state) => ({
    messages: {
      ...state.messages,
      [activeConversationId]: state.messages[activeConversationId].map((msg) =>
        msg.id === messageId ? { ...msg, content: '' } : msg
      ),
    },
    isGenerating: true,
  }));

  // 4. 重新调用 AI
  try {
    await window.electron.chat.send({
      conversationId: activeConversationId,
      messages: contextMessages,
      regenerateMessageId: messageId,
    });
  } finally {
    set({ isGenerating: false });
  }
},
```

---

## 消息编辑

### 流程

```
1. 用户编辑消息
2. 更新消息内容
3. 删除该消息之后的所有消息
4. 如果编辑的是用户消息，重新生成 AI 响应
```

### 实现

```typescript
// src/stores/chat.ts
editMessage: async (messageId: string, newContent: string) => {
  const { activeConversationId } = get();
  const messages = get().messages[activeConversationId];

  // 1. 找到消息位置
  const messageIndex = messages.findIndex((m) => m.id === messageId);
  if (messageIndex === -1) return;

  const message = messages[messageIndex];

  // 2. 更新消息内容，删除后续消息
  set((state) => ({
    messages: {
      ...state.messages,
      [activeConversationId]: state.messages[activeConversationId]
        .slice(0, messageIndex + 1)
        .map((msg) =>
          msg.id === messageId ? { ...msg, content: newContent } : msg
        ),
    },
  }));

  // 3. 如果是用户消息，重新生成 AI 响应
  if (message.role === 'user') {
    await get().sendMessage(newContent, { skipUserMessage: true });
  }
},
```

---

## 停止生成

### 实现

```typescript
// electron/services/chat-service.ts
export class ChatService {
  private abortController: AbortController | null = null;

  async *chat(messages: Message[]): AsyncGenerator<string> {
    this.abortController = new AbortController();

    try {
      const result = await streamText({
        model: this.getProvider(),
        messages,
        abortSignal: this.abortController.signal,
      });

      for await (const chunk of result.textStream) {
        yield chunk;
      }
    } catch (error) {
      if (error.name === "AbortError") {
        // 用户主动停止，不是错误
        return;
      }
      throw error;
    }
  }

  stopGeneration() {
    this.abortController?.abort();
  }
}

// electron/ipc/chat.ts
ipcMain.handle("chat:stop", () => {
  chatService.stopGeneration();
});
```

### 渲染进程调用

```typescript
// src/stores/chat.ts
stopGeneration: () => {
  window.electron.chat.stop();
  set({ isGenerating: false });
},
```

---

## 错误处理

### 错误类型

| 错误类型       | 描述     | 处理方式         |
| -------------- | -------- | ---------------- |
| NetworkError   | 网络错误 | 提示重试         |
| AuthError      | 认证错误 | 提示检查 API Key |
| RateLimitError | 频率限制 | 提示稍后重试     |
| ModelError     | 模型错误 | 显示错误信息     |
| TimeoutError   | 超时     | 提示重试         |

### 错误处理

```typescript
// src/stores/chat.ts
sendMessage: async (content: string) => {
  try {
    // ... 发送消息
  } catch (error) {
    // 更新消息状态为错误
    set((state) => ({
      messages: {
        ...state.messages,
        [activeConversationId]: state.messages[activeConversationId].map(
          (msg) =>
            msg.id === assistantMessage.id
              ? {
                  ...msg,
                  error: {
                    type: getErrorType(error),
                    message: getErrorMessage(error),
                  },
                }
              : msg
        ),
      },
      isGenerating: false,
    }));

    // 显示错误提示
    toast.error(getErrorMessage(error));
  }
},
```

---

## 性能优化

### 虚拟列表

对于长对话，使用虚拟列表优化渲染：

```typescript
// src/components/chat/MessageList.tsx
import { useVirtualizer } from '@tanstack/react-virtual';

function MessageList({ messages }: { messages: Message[] }) {
  const parentRef = useRef<HTMLDivElement>(null);

  const virtualizer = useVirtualizer({
    count: messages.length,
    getScrollElement: () => parentRef.current,
    estimateSize: () => 100,
    overscan: 5,
  });

  return (
    <div ref={parentRef} className="h-full overflow-auto">
      <div
        style={{
          height: `${virtualizer.getTotalSize()}px`,
          position: 'relative',
        }}
      >
        {virtualizer.getVirtualItems().map((virtualItem) => (
          <div
            key={virtualItem.key}
            style={{
              position: 'absolute',
              top: 0,
              left: 0,
              width: '100%',
              transform: `translateY(${virtualItem.start}px)`,
            }}
          >
            <MessageBubble message={messages[virtualItem.index]} />
          </div>
        ))}
      </div>
    </div>
  );
}
```

### 消息缓存

```typescript
// 使用 Zustand persist 中间件缓存消息
import { persist } from "zustand/middleware";

export const useChatStore = create<ChatStore>()(
  persist(
    (set, get) => ({
      // ... store 实现
    }),
    {
      name: "chat-storage",
      partialize: (state) => ({
        messages: state.messages,
        conversations: state.conversations,
      }),
    },
  ),
);
```

### 防抖输入

```typescript
// 输入时防抖保存草稿
const debouncedSaveDraft = useMemo(
  () =>
    debounce((content: string) => {
      localStorage.setItem(`draft-${conversationId}`, content);
    }, 500),
  [conversationId],
);
```

---

## 数据流图

```
┌─────────────────────────────────────────────────────────────────────┐
│                           渲染进程                                   │
│                                                                     │
│  ┌─────────┐    ┌─────────┐    ┌─────────┐                         │
│  │  组件   │───▶│  Store  │───▶│   IPC   │                         │
│  │ (View)  │◀───│(Zustand)│◀───│ Client  │                         │
│  └─────────┘    └─────────┘    └────┬────┘                         │
│                                      │                              │
└──────────────────────────────────────┼──────────────────────────────┘
                                       │ IPC
┌──────────────────────────────────────┼──────────────────────────────┐
│                           主进程                                     │
│                                 ┌────┴────┐                         │
│                                 │   IPC   │                         │
│                                 │ Handler │                         │
│                                 └────┬────┘                         │
│                                      │                              │
│         ┌────────────────────────────┼────────────────────────┐    │
│         │                            │                        │    │
│         ▼                            ▼                        ▼    │
│  ┌─────────────┐            ┌─────────────┐           ┌───────┐   │
│  │ ChatService │            │   Database  │           │  AI   │   │
│  │  (业务逻辑) │            │   (SQLite)  │           │ API   │   │
│  └─────────────┘            └─────────────┘           └───────┘   │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```
